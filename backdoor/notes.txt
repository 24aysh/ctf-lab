flag -> backdoorCTF{did_you_had_fun_solving_this_challenge??_i_had_a_lot_while_making_this_one....}

checks
length check


Feistel rounds / small block cipher (18 chars)
Idea: treat the entire input (or blocks) as the plaintext of a small Feistel network; encrypt with secret rounds and compare to a stored ciphertext.
Why: hides relation between input and expected output; reversible only if rounds/key known.
Pseudocode:

left,right = split(input_block)
for r in 0..R-1:
    tmp = left
    left = right ^ F(left, round_key[r])
    right = tmp
if concat(left,right) == expected: accept


    There will be 8 regs -> 6 general purpose reg
    1 ip (instruction pointer)
    1 zf (zero flag)
    ins -> 3 bytes ( 1 byte opcode , 1 byte operand each)


    0x1 movi reg,imm32
    0x2 mov reg,reg
    0x3 add reg,reg
    0x4 addi reg,imm32
    0x5 sub reg,reg
    0x6 subi reg,imm32
    0x7 mul  reg,reg
    0x8 muli reg,imm32
    0x9 xor reg,reg
    0x10 xori reg,imm32
    0x11 and reg,reg
    0x12 andi reg,imm32
    0x13 or reg,reg
    0x14 ori reg,imm32
    0x15 shl reg,reg
    0x16 shli reg,imm32
    0x17 shr reg,reg
    0x18 shri reg,imm32
    0x70 load
    0x80 store

    0x24 call addr
    0x25 ret
    0x40 jmp addr
    0x41 jnz addr
    0x42 jz addr
    0x43 cmp reg,reg
    0x44 cmpi reg,imm32

    0x90 nop
    0x91 halt


