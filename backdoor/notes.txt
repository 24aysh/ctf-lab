flag -> backdoorCTF{did_you_had_fun_solving_this_challenge??_i_had_a_lot_while_making_this_one....}
L = did_you_had_fun_solving_this_challenge?
R = ?_i_had_a_lot_while_making_this_one....

r6 contains the result of check
r0,r1,r2,r3 -> used while doing ciphers
r5 used as loop counter

Feistel rounds / small block cipher (18 chars)
Idea: treat the entire input (or blocks) as the plaintext of a small Feistel network; encrypt with secret rounds and compare to a stored ciphertext.
Why: hides relation between input and expected output; reversible only if rounds/key known.
Pseudocode:

left,right = split(input_block)
for r in 0..R-1:
    tmp = left
    left = right ^ F(left, round_key[r])
    right = tmp
if concat(left,right) == expected: accept


    There will be 8 regs -> 8 general purpose reg
    1 ip (instruction pointer)
    1 zf (zero flag)
    ins -> 3 bytes ( 1 byte opcode , 1 byte operand each)


    0x1 movi reg,imm32
    0x2 mov reg,reg
    0x3 add reg,reg
    0x4 addi reg,imm32
    0x5 sub reg,reg
    0x6 subi reg,imm32
    0x7 mul  reg,reg
    0x8 muli reg,imm32
    0x9 xor reg,reg
    0x10 xori reg,imm32
    0x11 and reg,reg
    0x12 andi reg,imm32
    0x13 or reg,reg
    0x14 ori reg,imm32
    0x15 shl reg,reg
    0x16 shli reg,imm32
    0x17 shr reg,reg
    0x18 shri reg,imm32
    0x19 movs reg,idx
    0x20 movk reg,idx
    0x70 load
    0x80 store

    0x24 call addr
    0x25 ret
    0x40 jmp addr
    0x41 jnz addr
    0x42 jz addr
    0x43 cmp reg,reg
    0x44 cmpi reg,imm32

    0x90 nop
    0x91 halt

   check length
   do 16 rounds Feistel transformation
   F function is sbox -> xor -> sbox
   
   load r4,mem[4]  // change the index
   load r0,mem[4]  // change the index
   mov r1,r0
   movs r0, r1
   movi r1,0  //change the index
   movk r2,r1
   xor r0,r2
   mov r1,r0
   movs r0,r1
   xor r0,r4
   load r3,mem[43]
   store mem{43},r0
   store mem[4],r3
   


movi r5,0
cmpi r5,16
jz .compare with hardcoded

movi r5 0
load r0 mem[4]
cmpi r0 217
jnz 0 3
addi r5 1
load r0 mem[5]
cmpi r0 87
